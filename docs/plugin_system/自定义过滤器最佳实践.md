# 自定义过滤器最佳实践

## 🚨 常见问题和解决方案

### 问题1: 类方法作为过滤器函数

#### ❌ 错误用法
```python
class MyPlugin(BasePlugin):
    def my_filter(self, event: BaseMessageEvent) -> bool:
        """这是一个实例方法，有 self 参数"""
        return 'test' in event.message.filter_text()
    
    @filter.custom(my_filter)  # ❌ 错误！
    async def handle_test(self, event: BaseMessageEvent):
        await event.reply("处理消息")
```

**问题**: 
- `my_filter` 是实例方法，需要 `self` 参数
- 在装饰器中传递时，还没有绑定到实例
- `CustomFilter` 调用时会失败

#### ✅ 正确用法

**方案1: 使用 lambda 表达式**
```python
class MyPlugin(BasePlugin):
    @filter.custom(lambda event: 'test' in event.message.filter_text())
    async def handle_test(self, event: BaseMessageEvent):
        await event.reply("处理消息")
```

**方案2: 使用独立函数**
```python
def my_filter(event: BaseMessageEvent) -> bool:
    """独立函数，不需要 self"""
    return 'test' in event.message.filter_text()

class MyPlugin(BasePlugin):
    @filter.custom(my_filter)
    async def handle_test(self, event: BaseMessageEvent):
        await event.reply("处理消息")
```

### 问题2: 高级过滤器的参数顺序

#### ❌ 错误用法
```python
class MyPlugin(BasePlugin):
    def admin_filter(self, manager, event: BaseMessageEvent) -> bool:
        """3个参数的方法"""
        return manager.rbac_manager.user_has_role(event.user_id, "admin")
    
    @filter.custom(admin_filter)  # ❌ 错误！签名验证失败
```

**问题**: 
- `CustomFilter` 只支持1个或2个参数的函数
- 3个参数（包括 self）会导致签名验证失败

#### ✅ 正确用法

**方案1: 使用 lambda 表达式（推荐）**
```python
class MyPlugin(BasePlugin):
    @filter.custom(lambda manager, event: 
                   manager.rbac_manager.user_has_role(event.user_id, "admin"))
    async def admin_command(self, event: BaseMessageEvent):
        await event.reply("管理员命令")
```

**方案2: 使用独立函数**
```python
def admin_filter(manager, event: BaseMessageEvent) -> bool:
    """独立函数，2个参数"""
    return manager.rbac_manager.user_has_role(event.user_id, "admin")

class MyPlugin(BasePlugin):
    @filter.custom(admin_filter)
    async def admin_command(self, event: BaseMessageEvent):
        await event.reply("管理员命令")
```

## ✅ 推荐的使用模式

### 1. Lambda 表达式（推荐用于简单逻辑）

```python
class MyPlugin(BasePlugin):
    # 简单条件检查
    @filter.custom(lambda event: 'hello' in event.message.filter_text())
    async def handle_hello(self, event: BaseMessageEvent):
        await event.reply("你好！")
    
    # 复杂条件检查
    @filter.custom(lambda event: 
        len(event.message.filter_text()) > 10 and 
        'important' in event.message.filter_text().lower()
    )
    async def handle_important(self, event: BaseMessageEvent):
        await event.reply("重要消息已处理")
    
    # 权限检查
    @filter.custom(lambda manager, event: 
        manager.rbac_manager.user_has_role(event.user_id, "admin")
    )
    async def admin_only(self, event: BaseMessageEvent):
        await event.reply("管理员专用功能")
```

### 2. 独立函数（推荐用于复杂逻辑和复用）

```python
# 在插件类外部定义独立函数
def contains_emoji(event: BaseMessageEvent) -> bool:
    """检查消息是否包含表情"""
    emoji_chars = ['😀', '😂', '🤔', '👍', '❤️']
    text = event.message.filter_text()
    return any(emoji in text for emoji in emoji_chars)

def is_weekend(event: BaseMessageEvent) -> bool:
    """检查是否是周末"""
    import datetime
    return datetime.datetime.now().weekday() >= 5

def admin_with_keyword(manager, event: BaseMessageEvent) -> bool:
    """管理员权限 + 关键词检查"""
    return (
        manager.rbac_manager.user_has_role(event.user_id, "admin") and
        'admin_cmd' in event.message.filter_text()
    )

class MyPlugin(BasePlugin):
    @filter.custom(contains_emoji)
    async def handle_emoji(self, event: BaseMessageEvent):
        await event.reply("表情消息 😀")
    
    @filter.custom(is_weekend)
    async def weekend_service(self, event: BaseMessageEvent):
        await event.reply("周末服务")
    
    @filter.custom(admin_with_keyword)
    async def admin_command(self, event: BaseMessageEvent):
        await event.reply("管理员命令执行")
```

### 3. 类型注解最佳实践

```python
from typing import TYPE_CHECKING
from ncatbot.core.event import BaseMessageEvent

if TYPE_CHECKING:
    from ncatbot.plugin_system.builtin_plugin.filter_registry import FilterRegistryPlugin

# 简单过滤器
def simple_filter(event: BaseMessageEvent) -> bool:
    """带完整类型注解的简单过滤器"""
    return 'test' in event.message.filter_text()

# 高级过滤器
def advanced_filter(manager: "FilterRegistryPlugin", event: BaseMessageEvent) -> bool:
    """带完整类型注解的高级过滤器"""
    return manager.rbac_manager.user_has_role(event.user_id, "admin")

class MyPlugin(BasePlugin):
    @filter.custom(simple_filter)
    async def handle_simple(self, event: BaseMessageEvent):
        await event.reply("简单过滤器")
    
    @filter.custom(advanced_filter)
    async def handle_advanced(self, event: BaseMessageEvent):
        await event.reply("高级过滤器")
```

## 🔧 调试技巧

### 1. 启用调试日志

```python
from ncatbot.utils import get_log
LOG = get_log(__name__)

def debug_filter(event: BaseMessageEvent) -> bool:
    """带调试信息的过滤器"""
    result = 'debug' in event.message.filter_text()
    LOG.debug(f"调试过滤器: 消息='{event.message.filter_text()}', 结果={result}")
    return result
```

### 2. 异常处理

```python
def safe_filter(event: BaseMessageEvent) -> bool:
    """带异常处理的过滤器"""
    try:
        # 复杂的逻辑
        return complex_logic(event)
    except Exception as e:
        LOG.error(f"过滤器执行异常: {e}")
        return False  # 异常时返回 False
```

### 3. 验证函数签名

确保过滤器函数符合以下签名之一：
- `(event: BaseMessageEvent) -> bool`
- `(manager: FilterRegistryPlugin, event: BaseMessageEvent) -> bool`

## 🚫 应避免的模式

1. **类方法作为过滤器**: 不要使用需要 `self` 的实例方法
2. **超过2个参数**: `CustomFilter` 只支持1-2个参数
3. **没有类型注解**: 虽然可选，但建议添加类型注解
4. **复杂的 lambda**: 对于复杂逻辑，使用独立函数更清晰
5. **忽略异常**: 过滤器中的异常可能导致整个处理流程中断

## 📝 总结

- ✅ 使用 lambda 表达式处理简单逻辑
- ✅ 使用独立函数处理复杂逻辑和实现复用
- ✅ 添加完整的类型注解
- ✅ 在过滤器中添加适当的异常处理
- ❌ 避免使用类的实例方法作为过滤器
- ❌ 避免超过2个参数的函数签名

